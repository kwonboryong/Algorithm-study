<br/>

## ✅ 스택 (stack)
: **데이터를 쌓는 형태**
- 마지막에 들어온 데이터가 먼저 나가는 **LIFO(Last In First Out, 후입선출) 형태의 자료구조**
- 주로 어떤 **작업의 실행을 취소**할 때, **웹 브라우저에서 뒤로가기** 할 때 등 최근에 처리한 작업들을 하나씩 꺼낼 때 사용한다.
- **속성**
   - top : 스택의 맨 위에 쌓인 아이템
- **메서드**
   - push : 스택의 맨 위에 쌓인 아이템을 삽입한다.
   - pop : 스택 맨 위의 아이템을 반환 & 제거한다.
   - peek : 스택 맨 위의 아이템을 반환한다. (제거 X)
   - contains : 해당 아이템이 스택에 존재하는지 확인한다.
   - size : 현재 스택에 있는 아이템의 총 개수를 반환한다.
- [스택 구현](https://github.com/kwonboryong/Algorithm/blob/main/Algorithm/CS-Theory/Data-Structures/stack.js)

![](https://blog.kakaocdn.net/dn/oSFa7/btsBUBpakEE/wcfINHu4lfNki8GhNKc2q1/img.png) <br/>
출처: [스택](https://engineerinsight.tistory.com/315#google_vignette)

<br/><br/>

### ☑️ 데이터 삽입 (Push)
: **스택에 새로운 데이터를 추가하는 연산**을 push라고 한다. 
- 이 연산은 **스택의 가장 위(top)에 데이터를 저장**한다.
- **구조**
  - 스택은 **top이라는 변수를 이용해 현재 가장 위에 있는 데이터의 위치를 기억**한다. 
  - 이로 인해 **데이터가 추가될 때, top의 위치를 업데이트하며 새로운 데이터를 그 위치에 저장**한다.
- **시간 복잡도: 상수 시간 or O(1)**
  - 스택의 최상위에 요소를 추가하는 작업은 상수 시간 내에 완료된다.

<br/>

### ☑️ 데이터 삭제 (Pop)
: **스택에서 데이터를 제거하는 연산**을 pop이라고 한다. 
- 이 연산은 **스택에서 가장 마지막에 저장된 데이터를 삭제**한다.
- **구조**
  - **top 변수를 사용하여 가장 마지막에 저장된 데이터를 찾아 삭제**한다. 
  - **이때 top이 가리키는 위치를 하나 감소시킨다.**
- **시간 복잡도: 상수 시간 or O(1)**
  - 스택의 최상위 요소를 제거하는 작업도 상수 시간 내에 완료된다.

![](https://blog.kakaocdn.net/dn/bpQpWC/btsBUBW0jR0/a8QnC1hkCzYqQ5YJd19KE1/img.png) <br/>
출처: [스택 연산](https://engineerinsight.tistory.com/315#google_vignette)

<br/>

### ☑️ 최상위 데이터 조회 (Peek)
: **스택의 최상위 요소를 반환하는 것**을 peek이라고 한다. 
- 스택의 최상위 요소를 확인할 수 있지만, 그 요소를 스택에서 삭제하지는 않는다.
- **시간 복잡도: 상수 시간 or O(1)**
  - 상위 요소를 조회하는 작업도 상수 시간 내에 완료된다.

<br/><br/>

#### ⏩ 스택(stack) 구현 방법
- **배열(Array)을 이용한 스택**
   - 배열의 끝부분을 스택의 top으로 간주하여 push나 pop 연산을 수행한다.
   - **배열의 크기가 제한되므로, 스택의 크기도 제한적**이다.


- **연결 리스트(Linked List)를 이용한 스택**
   - 연결 리스트의 맨 앞이나 맨 끝을 top으로 설정하여 push와 pop을 수행한다. 
   - **동적으로 메모리를 사용하므로 스택의 크기에 제한이 없고, 메모리 사용이 더 효율적이**다.

<br/>

### 참고
- [ep5. 스택 (Stack) | JS 알고리즘 마스터 클래스](https://youtu.be/cfml7k66-iU?si=9s6GuuCtwPUjnNng)


<br/><br/>
<br/>

## ✅ 큐 (queue)
: **데이터가 순차적으로 들어오는 형태**
- 먼저 들어온 데이터가 먼저 나가는 **FIFO(First in First out, 선입선출) 형태의 자료구조**
- 예시
   - **운영체제에서 프로세스가 CPU를 할당받기 전까지 대기하는 준비 큐** 
   - 어떠한 작업을 처리할 때 **작업 요청이 들어온 순서대로 처리**할 때 큐를 사용
- **시간 복잡도: O(n) or O(1)**
  - 내부적으로 어떤 자료구조로 구현하는가에 따라 시간 복잡도가 달라진다.
     - 배열로 구현 시: O(n)
     - 연결 리스트로 구현 시: O(1)
- [큐 구현](https://github.com/kwonboryong/Algorithm/blob/main/Algorithm/CS-Theory/Data-Structures/queue.js)

![](https://t1.daumcdn.net/cfile/tistory/9929C0495C932BB115) <br/>
출처: [큐](https://galid1.tistory.com/483)

<br/><br/>

### ☑️ 데이터 삽입 (Enqueue)
: **큐에 데이터를 추가하는 연산**을 **인큐(enqueue)**라고 한다. 
- 이 연산은 **큐의 맨 뒤(rear)에 데이터를 삽입**한다.
- **구조**
  - 큐의 맨 뒤에 데이터를 추가하기 위해 **rear 포인터를 사용**한다. 
  - **rear는 새로운 데이터가 추가될 때마다 한 칸씩 뒤로 이동**하며, **새로운 데이터를 그 위치에 삽입**한다.
- **시간 복잡도: O(1)**
  - 큐의 맨 뒤에 데이터를 추가하는 연산은 데이터 위치를 이동할 필요가 없으므로 O(1)의 시간 복잡도를 가진다.

<br/>

### ☑️ 데이터 삭제 (Dequeue)
: **큐에서 데이터를 제거하는 연산**을 **디큐(dequeue)**라고 한다. 
- 이 연산은 **큐의 맨 앞(front)에 있는 데이터를 삭제**한다.
- **구조**
  - 큐의 맨 앞에 있는 데이터를 제거하기 위해 **front 포인터를 사용**한다. 
  - **front는 데이터가 삭제될 때마다 한 칸씩 뒤로 이동하며, 큐의 다음 데이터를 가리키게 된다.**
- **시간 복잡도: O(1)**
  - 큐의 맨 앞에서 데이터를 삭제하는 연산도 데이터 위치를 이동할 필요가 없으므로 O(1)의 시간 복잡도를 가진다.

<br/>

![](https://miro.medium.com/v2/resize:fit:736/1*MJE8cRN-EHoFyJJEfFx-Xw.png)

<br/><br/>

#### ⏩ 큐(queue) 구현 방법
- **배열(Array)을 이용한 큐**
   - **큐의 맨 앞과 맨 뒤를 각각 front와 rear로 설정하여, enqueue와 dequeue 연산을 수행한다.**
   - **배열을 사용하면 큐가 가득 찼을 때, 배열의 크기를 증가시키거나 순환 큐(circular queue)를 사용해야 한다.**

- **연결 리스트(Linked List)를 이용한 큐**
   - **rear와 front 포인터를 사용하여 enqueue와 dequeue 연산을 수행**한다.
   - **메모리 공간을 동적으로 사용할 수 있어 큐의 크기에 제한이 없다.**

<br/><br/>

#### ⏩ 배열(Array)로 구현한 큐의 문제점
- **큐가 가득 찼는지 확인하는 방법**
  - 큐를 배열로 구현하면, **rear 인덱스를 사용해 큐가 가득 찼는지 쉽게 확인할 수 있다.**
  - **큐에 데이터를 추가할 때마다 rear가 증가하고, 이 값이 배열의 크기와 같아지면 큐가 가득 찼다고 본다.**
- **인큐/디큐 시 front와 rear 수정**
  - **큐에서 데이터를 추가할 때(enqueue)나 삭제할 때(dequeue), front나 rear 인덱스만 수정하면 된다.**
  - 이 작업은 시간 복잡도가 **O(1)**로, 매우 빠르게 처리된다.
- **큐의 가득 참 상태 오류**
  - **큐가 가득 찬 후 일부 데이터를 삭제하면, rear 인덱스는 여전히 배열의 끝에 머물러 있을 수 있다.**
  - 이 경우, **실제로는 빈 공간이 있지만 rear의 위치 때문에 큐가 가득 찼다고 잘못 판단할 수 있다.**

<br/><br/>

#### ⏩ 순환 큐
:  배열의 끝에 도달해도 배열의 처음으로 돌아가서 데이터를 추가할 수 있는 구조
- 이 방식으로 **큐가 꽉 차는 문제를 해결**할 수 있다.
- **데이터 삽입의 유연성**
  - **배열의 어느 위치에서든 데이터를 유연하게 추가하거나 삭제할 수 있다.**
  - 배열의 시작과 끝이 연결된 것처럼 동작하기 때문에, 큐의 끝에서 다시 처음으로 돌아가 데이터를 추가할 수 있다.
- **장점**
  - 순환 큐를 사용하면 **배열의 공간을 최대한 활용**할 수 있다. 
  - **큐가 가득 찬 상태를 잘못 판단하는 문제를 해결**할 수 있다.

<br/>

### 참고
- [ep6. 큐 (Queue) | JS 알고리즘 마스터 클래스](https://youtu.be/VHerL9C0624?si=1sLNvYWOvrTYTqhM)

<br/><br/>
